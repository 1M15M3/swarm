@node Usage, API, Running a node, Top
@chapter Usage


@menu
* Upload directory, upload file::
* Setting up your chequebook::
* Configure
* Download directory, download file::
* On demand partial reads::
* Auto restart::
* Register and resolve domain names::
* Versioning by block number::
* Modifying content::
* Expiry::
* Manifest::
@end menu


@subsection Using a local Swarm Instance

@subsubsection Running your client
To start a swarm node we must start geth with an empty data directory on a private network. First set aside an empty temporary directory to be the data store

@codequotebacktick on
@codequoteundirected on

@example
 DATADIR=/tmp/BZZ/`date +%s`
@end example
 
then make a new account using this directory 

@example
 PASSWORD="mypassword"
 /geth --datadir $DATADIR --password  `echo -n $PASSWORD` account new
@end example

and finally, launch geth on a private network (id 322)

@example
    ./geth --datadir $DATADIR @backslashchar{} 
           --port 30301 @backslashchar{} 
           --unlock primary @backslashchar{} 
           --password `echo $PASSWORD` @backslashchar{} 
           --logfile $DATADIR/bzz.log @backslashchar{} 
           --logtostderr @backslashchar{} 
           --verbosity 6 @backslashchar{} 
           --rpc @backslashchar{} 
           --rpcport 8101 @backslashchar{} 
           --rpccorsdomain '*' @backslashchar{} 
           --bzz @backslashchar{} 
           --networkid 322 @backslashchar{} 
           --nodiscover @backslashchar{} 
           --maxpeers 0 @backslashchar{} 
           console   2>> $DATADIR/bzz.glog
@end example

At this verbosity level you should see plenty of output accumulating in the logfile. You can keep en eye on it using the command @command{tail -f $DATADIR/bzz.glog}.


@subsubsection Uploading a file or directory to your local swarm instance

Included in the swarm repository is a shell script that makes it easy to upload a file to a local swarm node using http port 8500.

@example
bash bzz/bzzup/bzzup.sh /path/to/myFileOrDirectory
@end example

If this command is successful, the output will be a hash
@example
65b2a32ab2230d7d2bad2616e804d374921be68758009491cd52c727e37b4979
@end example

If unsuccessful (for example if no local node is running) the output will simply be blank.

It is also possible to upload a file or directory from the console like this

@example
hash = bzz.upload("/path/to/myFileOrDirectory", "index.html")
@end example

Here the second parameter (index.html) is to be mapped to the root path '/'.

@subsubsection Downloading a file from your local swarm instance

Your local swarm instance has an http interface running on port 8500 (by default). To download a file is thus a simple matter of pointing your browser to

@example
http://localhost:8500/65b2a32ab2230d7d2bad2616e804d374921be68758009491cd52c727e37b4979
@end example

or, if you prefer, you can use the console 
@example
bzz.get(hash)
@end example




@subsection Manifests:

In general Manifests declare a list of strings associated with swarm entries. Before we get into generalities however, let us begin with an introductory example.

@subsubheading A Manifest example - directory trees

Suppose we had used @command{bzzup.sh} described above to upload a directory to swarm instead of just a file:

@example
bash bzz/bzzup/bzzup.sh /path/to/directory
@end example

then the resulting hash points to a "manifest" - in this case a list of files within the directory along with thir swarm hashes. Let us take a closer look.

@subsubheading The raw Manifest
We can see the raw Manifest by prepending @code{raw/} to the URL like so
@example
    wget -O - "http://localhost:8500/raw/HASH"
@end example

In our example it contains a list of all files contained in @code{/path/to/directory} together with their swarm ids (hashes) as well as their mime-types.

@subsubheading Path Matching on Manifests
A useful feature of manifests is that Urls can be matched on the paths. In some sense this makes the manifest a routing table and so the manifest swarm entry acts as if it were a host.

More concretely, continuing in our example, we can access the file 
@example
/path/to/directory/subdirectory/filename
@end example
by pointing the browser to
@example
http://localhost:8500/HASH/subdirectory/filename
@end example

Note: if the filename is @code{index.html} then it can be omitted.

@subsubheading Manifests in general
Although in our example above the manifest was essentially a file listing in a directory, there is no reason for a Manifest to take this form. Manifests simply match strings with swarm id's, and there is no requirement that the strings be of the form @code{path/to/file}. Indeed swarm treats @code{path/to/file} as just another identifying string and there is nothing special about the @code{/} character.

@subsubheading more to document

@itemize @bullet
@item check manifest,  raw call
@item path matching, fallback, status
@item recursive resolution
@item insert/delete
@item downloadable
@end itemize

@subheading Paths

@itemize @bullet
@item forced content type
@item html assets with relative paths in the browser
@item fallback to existing parent path with url preserved
@item dynamic paths, resourceful routing, restful apis
@item error pages
@end itemize

@subheading The bzz scheme


@itemize @bullet
@item rewrite and proxy
@item bzz fully functional in console http url fetcher
@end itemize

@subsubsection  http module for urls on the console

the console http module is a very simple http client, that understands the bzz scheme if bzz is enabled.

@itemize @bullet
@item `http.get(url)`
@item `http.loadScript(url)` should be same as JSRE.loadScript
@end itemize

@subsubsection domain name registration

Any hash can be registered with a domain name, that can be used in the host part of the bzz scheme.
So it is exactly analogous to DNS, domain names and IP addresses.

@itemize @bullet
@item name registration
@item name resolution in the browser
@item mimicking mutability by namereg (latest)
@item versioning by blockheight
@end itemize


@subsection 



Bzz console API

@itemize @bullet
@item  `bzz.upload(localfspath, indexfile)` returns content hash
@item `bzz.download(bzzpath, localdirpath)` returns error
@item `bzz.put(content, contentType)` returns content hash
@item `bzz.get(bzzpath)` returns object with content, mime type, status code and content size
@item `bzz.register(address, hash, domain)` returns error
@item `bzz.resolve(domain)` returns content hash
@end itemize

@example
js
hash = bzz.upload("/path/to/my/directory")

hash = bzz.put("console.log(\"hello from console\")", "application/javascript")

bzz.get(hash)
{
  content: 'console.log("hello");',
  contentType: 'application/javascript',
  status: '0'
  size: '21',
}

http.get("bzz://"+hash)
'console.log("hello from console")'

http.loadScript("bzz://"+hash)
hello from console
true

bzz.register(primary, hash, "hello")
@end example

@subsection Using swarm for contract info

@subsubsection Prerequisites

@itemize @bullet
@item  globalRegistrar contract deployed
@item HashReg, UrlHint deployed and registered with globalRegistrar
@end itemize

These need to be done only once for every chain. See appendix.

If this was successful, you will see these commands respond with addresses.

@example
js
registrar.owner("HashReg");
registrar.owner("UrlHint");
registrar.addr("HashReg");
registrar.addr("UrlHint");
@end example

and these commands will respond with code:

@example
js
eth.getCode(globalRegistrarAddr);
eth.getCode(hashRegAddr);
eth.getCode(urlHintAddr);
@end example

If these checks are ok, you are all set up.

@subsubsection Creating and deploying a contract

@subsubsection Create contract and deploy compiled code to the blockchain

@example
js
admin.contractInfo.stop();

source = "contract test {@backslashchar{}n" +
"   /// @@notice will multiply `a` by 7.@backslashchar{}n" +
"   function multiply(uint a) returns(uint d) {@backslashchar{}n" +
"      return a * 7;@backslashchar{}n" +
"   }@backslashchar{}n" +
"} ";
contract = eth.compile.solidity(source).test;
contractaddress = eth.sendTransaction({from: primary, data: contract.code});
@end example

Check if they arrived on the blockchain and that they execute your calls by:

@example
js
code = eth.getCode(contractaddress);
abiDef = contract.info.abiDefinition;
multiply7 = eth.contract(abiDef).at(contractaddress);
multiply7.multiply.call(6);
@end example

@subsubsection Deploying off-chain contract info

The contract.info substructure given back from the solidity compiler can be deployed with swarm.
The resulting contenthash is registered in the HashReg.

@example
js
contenthash = bzz.put(JSON.stringify(contract.info), "application/eth-contractinfo+json");
admin.contractInfo.register(primary, contractaddress, contenthash);
@end example

You need to wait till it is mined and confirmed.

@subsubsection Contract usage from dapp (or user-side case)

`admin.contractInfo.get` will magically work. If the url fetcher has the bzz protocol scheme enabled, then it tries to fetch it with the registered contenthash. (If there is no swarm or the content is not (yet) uploaded there, it gracefully falls back to the UrlHint, ie., it looks up the url hint for the contentHash, fetches its content, and verifies it against the contentHash for protection.)

Note that the user needs the contractaddress but nothing else.

@example
js
info = admin.contractInfo.get(contractaddress);
multiply7 = eth.contract(info.abiDefinition).at(contractaddress);
@end example

Now that we  switch on natspec and try:

@example
js
admin.contractInfo.start();
multiply7.multiply.sendTransaction(6, { from: primary });
@end example

The following custom confirmation message should appear on the console and 6 shall be multiplied by seven:

@example
js
> myMultiply7.multiply.sendTransaction(6)
NatSpec: Will multiply 6 by 7.
Confirm? [y/n] y
@end example

@subsubsection Using name registrar for contracts

And now we can go one step further and use the globalRegistrar name registry for contracts:

@example
js
admin.contractInfo.stop();
registrar.reserve.sendTransaction("multiply7", {from:primary})
registrar.setAddress.sendTransaction("multiply7", contractaddress, true, {from:primary})
@end example

You need to wait for these 2 transactions to be confirmed. You can check if arrived:

@example
js
registrar.owner("multiply7")
@end example

Now the contract name is sufficient to use this contract from a Dapp.

@example
js
contractaddress = registrar.addr("multiply7")
info = admin.contractInfo.get(contractaddress);
multiply7 = eth.contract(info.abiDefinition).at(contractaddress);
@end example

If info is only needed because of the Abi, then one could define this function:

@example
js
getContract = function(name) {
  contractaddress = registrar.addr(name)
  info = admin.contractInfo.get(contractaddress);
  return eth.contract(info.abiDefinition).at(contractaddress);
}
@end example




@example
js
web3.sha3(eth.getCode(registrar.addr("multiply7")))
51b68b0f44e8c6ef096797efbed04185fd4c4a639cd5ffe52e96076519c1385d
@end example

@subheading bzz domain names, registration, resolution

@example
js
bzz.upload("/Users/tron/Work/ethereum/go-ethereum/bzz.demo/luzhany/")
'51b68b0f44e8c6ef096797efbed04185fd4c4a639cd5ffe52e96076519c1385d'
bzz.register(primary, "album", "0x51b68b0f44e8c6ef096797efbed04185fd4c4a639cd5ffe52e96076519c1385d")
true
bzz.resolve("album")
unable to resolve 'album': content hash not found for '0x3ae883aa85e0554e92a3ab951b5cf9f7e045e742618560ec3fe62d80800e8673'
undefined
@end example

oops you need to mine it or wait for concensus.

@example
js
admin.miner.start(); admin.debug.waitForBlocks(eth.blockNumber+1); admin.miner.stop();
true
bzz.resolve("album")
'0x51b68b0f44e8c6ef096797efbed04185fd4c4a639cd5ffe52e96076519c1385d'
@end example

homomorphic:

@example
js
bzz.download("/album", "/tmp/album")
undefined
bzz.upload("/tmp/album")
'51b68b0f44e8c6ef096797efbed04185fd4c4a639cd5ffe52e96076519c1385d'
@end example

Open a page via path (matching, fallbacks errors)

@example
js
http.get("bzz://51b68b0f44e8c6ef096797efbed04185fd4c4a639cd5ffe52e96076519c1385d/index.html")
http.get("bzz://album/index.html")
http.get("bzz://album/index.css")
@end example

to get raw content, override these

@example
js
http.get("http://raw/album/?content\_type=\"text/plain\"")
'{"entries":[{"path":"add.png","hash":"8fbac5d742128d4a2cd1c453201c9300280b9ea7f132eac66c0bb9e9dedeb3ff","contentType":"image/png","status":0},{"path":"back.png","hash":"f7ef5a708262258cc59b261849d1794dcafa9319848990dda05b1cf814ffe7c8","contentType":"image/png","status":0},{"path":"cut-","hash":"c1710a9cd0cd34261d80288f1b694fcf9ce814788457bd74bbaf5e1c08eab26e","contentType":"application/bzz-manifest+json","status":0},{"path":"d","hash":"b69bd4600643c2563934e36260b7f7b91e59cf6ab130854882833b922da639a9","contentType":"application/bzz-manifest+json","status":0},{"path":"eye.png","hash":"bc3fc186c7c02a7841acfb1de3e61bcef870e8d81588dd05827d028b5b310536","contentType":"image/png","status":0},{"path":"i","hash":"4ae40ee14730629c12937ccd732eef1e3b0ffb8df1b759ea9946aba5296c0bef","contentType":"application/bzz-manifest+json","status":0},{"path":"left.png","hash":"a6093a7b7b8fae95fee097125e90c4d1477d8948f1f24ac241cc4e2ff55872e1","contentType":"image/png","status":0},{"path":"mootools-","hash":"ebf08b45f54021e764c163b2b7083cb7a05ae4c88cce1986e0599e79036c16ad","contentType":"application/bzz-manifest+json","status":0},{"path":"noise.png","hash":"90254e6274ef150f5ccb7c61fd6bd9c0614abf18306d43b9e79a7f738f84831f","contentType":"image/png","status":0},{"path":"right.png","hash":"88a26306bd909a3bc34201a1e18c3f1767069a48019caedfb4fd64c8556521b9","contentType":"image/png","status":0},{"path":"throbber.gif","hash":"583bd22d262b2192399d97f5daf04516b620b95b607c94f5051f515fb4137d9d","contentType":"image/gif","status":0}]}'
@end example

@subsubsection Changes, versions, rollback

@example
js
bzz.register(primary, "swarm", bzz.upload("bzz.demo/swarm-inside.png", "swarm-inside.png"))
@end example

after some mining or wait, take a look at http://localhost:8500/swarm/
Now resolver should work too:

@example
js
bzz.resolve("swarm")
'0x58c604de89bf3ecbbbfc90948b273ae3f956e6106babd5e8bacb3615213d3c2e'
@end example

lets remember this version, just record the current block.

@example
js
v1 = eth.blockNumber
31
@end example

[http://localhost:8500/swarm/]
Now i realise i left out the logo, so

@example
js
bzz.register(primary, "swarm", bzz.upload("bzz.demo/MSTR-Swarm-Logo.jpg", "MSTR-Swarm-Logo.jpg"))
true
miner.start(); admin.sleepBlocks(1); miner.stop();
true
bzz.resolve("swarm")
'0x8232b8259393019920d57737c1073c78a6cee18ffa8bfcfdc0cd378a732415a8'
v2 = eth.blockNumber
33
@end example

the full historical record is addressable:

[http://localhost:8500/swarm@@31/] vs [http://localhost:8500/swarm@@32/]

Finally you can see it with the bzz-aware http client:

@example
js
> http.get("bzz://raw/swarm:"+v1+"?content\_type=text/json")
'{"entries":[{"path":"swarm-inside.png","hash":"a41a826e6dae90816e432993576d2418c33f40f4e6774df457706e2890202228","contentType":"image/png","status":0},{"path":"","hash":"a41a826e6dae90816e432993576d2418c33f40f4e6774df457706e2890202228","contentType":"image/png","status":0}]}'
> http.get("bzz://raw/swarm:"+v2+"?content\_type=text/json")
'{"entries":[{"path":"MSTR-Swarm-Logo.jpg","hash":"35e6a17fab09d7f84f1feacfe629a2c0660d6c3ca70db5c8ff2c7ac2c537ce1d","contentType":"image/jpeg","status":0},{"path":"","hash":"35e6a17fab09d7f84f1feacfe629a2c0660d6c3ca70db5c8ff2c7ac2c537ce1d","contentType":"image/jpeg","status":0}]}'
@end example

@subsection Appendix

@subsubsection mine some ether on a private chain

@example
js
primary = eth.accounts[0];
balance = web3.fromWei(eth.getBalance(primary), "ether");

admin.miner.start(8);
admin.sleepBlocks(10);
admin.miner.stop()  ;
@end example

@subsubsection mine transactions on a private chain

@example
js
eth.getBlockTransactionCount("pending");
eth.getBlock("pending", true).transactions;

miner.start(1);
admin.sleepBlocks(eth.blockNumber+1);
miner.stop();

eth.getBlockTransactionCount("pending");
@end example

@subsubsection create and deploy GlobalRegistrar, HashReg and UrlHint

@example
primary = eth.accounts[0];
globalRegistrarAddr = admin.setGlobalRegistrar(primary);
hashRegAddr = admin.setHashReg(primary);
urlHintAddr = admin.setUrlHint(primary);
@end example

You need to mine or wait till the txs are all picked up.
Initialise the registrar on the new address and check if the other registars are registered:

@example
js
registrar = GlobalRegistrar.at(globalRegistrarAddr);
registrar.owner("HashReg");
registrar.owner("UrlHint");
registrar.addr("HashReg");
registrar.addr("UrlHint");
@end example

Next time you only need to specify the address of the GlobalRegistrar (for the live chain it is encoded in the code)

@example
admin.setGlobalRegistrar("0x6e332ff2d38e8d6f21bee5ab9a1073166382ce33")
registrar = GlobalRegistrar.at(GlobalRegistrarAddr);
registrar.owner("HashReg");
registrar.owner("UrlHint");
registrar.addr("HashReg");
registrar.addr("UrlHint");
@end example

